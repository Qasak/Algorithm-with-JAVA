package leetcode.template.UnionFind;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Wangjs
 * @version 1.0
 * @date 2021/1/27 13:14
 */
public class Q1579_MaxNumEdgesRemove {
    // 可以删除的最大边数
    /*
13
[[1,1,2],[2,1,3],[3,2,4],[3,2,5],[1,2,6],[3,6,7],[3,7,8],[3,6,9],[3,4,10],[2,3,11],[1,5,12],[3,3,13],[2,1,10],[2,6,11],[3,5,13],[1,9,12],[1,6,8],[3,6,13],[2,1,4],[1,1,13],[2,9,10],[2,1,6],[2,10,13],[2,2,9],[3,4,12],[2,4,7],[1,1,10],[1,3,7],[1,7,11],[3,3,12],[2,4,8],[3,8,9],[1,9,13],[2,4,10],[1,6,9],[3,10,13],[1,7,10],[1,1,11],[2,4,9],[3,5,11],[3,2,6],[2,1,5],[2,5,11],[2,1,7],[2,3,8],[2,8,9],[3,4,13],[3,3,8],[3,3,11],[2,9,11],[3,1,8],[2,1,8],[3,8,13],[2,10,11],[3,1,5],[1,10,11],[1,7,12],[2,3,5],[3,1,13],[2,4,11],[2,3,9],[2,6,9],[2,1,13],[3,1,12],[2,7,8],[2,5,6],[3,1,9],[1,5,10],[3,2,13],[2,3,6],[2,2,10],[3,4,11],[1,4,13],[3,5,10],[1,4,10],[1,1,8],[3,3,4],[2,4,6],[2,7,11],[2,7,10],[2,3,12],[3,7,11],[3,9,10],[2,11,13],[1,1,12],[2,10,12],[1,7,13],[1,4,11],[2,4,5],[1,3,10],[2,12,13],[3,3,10],[1,6,12],[3,6,10],[1,3,4],[2,7,9],[1,3,11],[2,2,8],[1,2,8],[1,11,13],[1,2,13],[2,2,6],[1,4,6],[1,6,11],[3,1,2],[1,1,3],[2,11,12],[3,2,11],[1,9,10],[2,6,12],[3,1,7],[1,4,9],[1,10,12],[2,6,13],[2,2,12],[2,1,11],[2,5,9],[1,3,8],[1,7,8],[1,2,12],[1,5,11],[2,7,12],[3,1,11],[3,9,12],[3,2,9],[3,10,11]]

12
[[3,1,2],[2,2,3],[3,1,4],[2,3,5],[1,2,6],[2,4,7],[3,3,8],[3,2,9],[2,1,10],[2,1,11],[1,11,12],[1,10,11],[2,5,9],[2,7,10],[2,4,12],[3,9,10],[1,6,9],[2,10,12],[1,2,5],[3,5,6],[1,7,11],[1,8,9],[1,1,11],[3,4,5],[1,5,9],[2,4,9],[1,8,11],[3,6,8],[1,8,10],[2,2,4],[2,3,8],[3,2,6],[3,10,11],[2,3,11],[3,5,9],[3,3,5],[2,6,11],[3,2,7],[1,5,11],[1,1,5],[2,9,10],[1,6,7],[3,2,3],[2,8,9],[3,2,8]]
    */
    class UF {
        int[] uf;
        int cnt;
        int N;
        public UF(int n) {
            uf = new int[n];
            for(int i = 0; i < n; i++) {
                uf[i] = i;
            }
            cnt = n - 1;
            N = n;
        }
        public UF(UF o) {
            this.N = o.N;
            uf = new int[N];
            for(int i = 0; i < N; i++) {
                uf[i] = o.uf[i];
            }
            cnt = o.cnt;
        }
        int find(int x) {
            if(x == uf[x]) {
                return x;
            }
            return uf[x] = find(uf[x]);
        }
        void union(int x, int y) {
            int px = find(x); int py = find(y);
            if(px != py) {
                uf[px] = py;
                cnt--;
            }
        }
    }
    public int maxNumEdgesToRemove(int n, int[][] edges) {
        UF uf = new UF(n + 1);
        List<int[]> e3 = new ArrayList<>();
        List<int[]> e1 = new ArrayList<>();
        List<int[]> e2 = new ArrayList<>();
        for(int[] e: edges) {
            if(e[0] == 3) {
                e3.add(new int[]{e[1], e[2]});
            }
            if(e[0] == 1) {
                e1.add(new int[]{e[1], e[2]});
            }
            if(e[0] == 2) {
                e2.add(new int[]{e[1], e[2]});
            }
        }

        int cnt3 = 0;
        for(int[] e: e3) {
            if(uf.find(e[0]) != uf.find(e[1])) {
                cnt3++;
                uf.union(e[0], e[1]);
            }
        }
        // cnt: 每种边用完后的剩余数量
        cnt3 = e3.size() - cnt3;
        UF uf1 = new UF(uf);
        int cnt1 = 0;
        for(int[] e: e1) {
            if(uf1.find(e[0]) != uf1.find(e[1])) {
                cnt1++;
                uf1.union(e[0], e[1]);
            }
        }
        cnt1 = e1.size() - cnt1;
        UF uf2 = new UF(uf);
        int cnt2 = 0;
        for(int[] e: e2) {
            if(uf2.find(e[0]) != uf2.find(e[1])) {
                cnt2++;
                uf2.union(e[0], e[1]);
            }
        }
        cnt2 = e2.size() - cnt2;
        // System.out.println(uf2.cnt + " " + cnt2);
        // 1,2两种集合还没有联通
        if((uf1.cnt > 1 || uf2.cnt > 1)) {
            return -1;
        }
        return cnt1 + cnt2 + cnt3;
    }
}
