/*
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
**/

/*
投掷 n 个骰子，所有点数出现的总次数是 6^n 

我们的目的就是 计算出每次投掷完 n枚骰子后每个可能的和出现的次数。

getCount(n, k):投掷 n 枚骰子，点数的和 k 出现的次数

getCount(2,4)=getCount(1,1)+getCount(1,2)+getCount(1,3)
两个筛子和为4，只能是13，22，31，第一个筛子是1时表示剩下一个筛子（的和）必为3，就是getCount（1，3）,以此类推
getCount(2,6)=getCount(1,1)+getCount(1,2)+getCount(1,3)+getCount(1,4)+getCount(1,5)



1.表示状态
2.找出状态转移方程
3.边界处理

分析问题的状态时，不要分析整体，只分析最后一个阶段即可
通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：当投掷完 n 枚骰子后，各个点数(前n枚骰子的点数和)出现的次数。
1.
首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子
然后用第二维来表示投掷完这些骰子后，可能出现的点数。
数组的值就表示，该阶段各个点数出现的次数。
所以状态表示就是这样的：dp[i][j] ，表示投掷完 i 枚骰子后，点数 j 的出现次数
2.
同样我们还是只需分析最后一个阶段
最后一个阶段也就是投掷完 n 枚骰子后的这个阶段，我们用 dp[n][j] 来表示最后一个阶段点数 j 出现的次数。

单单看第 n 枚骰子，它的点数可能为 1 ,2, 3, ... , 6
因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n-1枚骰子后，
对应点数 j-1, j-2, j-3, ... , j-6出现的次数之和转化过来。

for (第n枚骰子的点数 i = 1; i <= 6; i ++) {
    dp[n][j] += dp[n-1][j - i]
}
3.
这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。

我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 1枚骰子后，它的可能点数分别为 1, 2, 3, ... , 6并且每个点数出现的次数都是 1 .
for (int i = 1; i <= 6; i ++) {
    dp[1][i] = 1;
}



**/

class Solution {
    public double[] dicesProbability(int n) {
        double[][] dp= new double[20][70];
        for(int i = 1; i <=6; i++) {
            dp[1][i] = 1.0;
        }
        for(int i = 2; i<=n; i++) {
            for(int j = i; j <= 6*i; j++) {
                for(int cur = 1; cur <= 6; cur++) {
                    if(j - cur <= 0) {
                        break;
                    }
                    dp[i][j] += dp[i - 1][j - cur];
                }
            }
        }
        double tot = Math.pow(6, n);
        double[] ans = new double[5*n + 1];
        // 最后一次转移：最小值为n
        for(int i = n; i <= 6*n; i++) {
            ans[i - n] = (dp[n][i] * 1.0 / tot);
        }
        return ans;

    }
}